/*
 * generated by Xtext 2.15.0
 */
package com.modelsolv.reprezen.restapi.xtext.ui.contentassist

import com.google.common.base.Function
import com.google.common.base.Joiner
import com.google.common.base.Optional
import com.google.common.base.Predicate
import com.google.common.collect.Iterables
import com.google.common.collect.Lists
import com.google.inject.Inject
import com.modelsolv.reprezen.core.ConfigVariable
import com.modelsolv.reprezen.core.workspace.WorkspaceUtils
import com.modelsolv.reprezen.restapi.Feature
import com.modelsolv.reprezen.restapi.ImportDeclaration
import com.modelsolv.reprezen.restapi.MessageParameter
import com.modelsolv.reprezen.restapi.ObjectRealization
import com.modelsolv.reprezen.restapi.PrimitiveProperty
import com.modelsolv.reprezen.restapi.PropertyRealization
import com.modelsolv.reprezen.restapi.RealizationContainer
import com.modelsolv.reprezen.restapi.ReferenceProperty
import com.modelsolv.reprezen.restapi.RestapiPackage
import com.modelsolv.reprezen.restapi.Structure
import com.modelsolv.reprezen.restapi.TypedMessage
import com.modelsolv.reprezen.restapi.TypedResponse
import com.modelsolv.reprezen.restapi.datatypes.cardinality.Cardinality
import com.modelsolv.reprezen.restapi.datatypes.cardinality.FeatureCardinalities
import com.modelsolv.reprezen.restapi.datatypes.cardinality.OverrideCardinalities
import com.modelsolv.reprezen.restapi.util.InheritanceUtils
import com.modelsolv.reprezen.restapi.util.RestapiModelUtils
import com.modelsolv.reprezen.restapi.xtext.services.RapidMLGrammarAccess
import com.modelsolv.reprezen.restapi.xtext.ui.RepreZenUIImages
import java.util.ArrayList
import java.util.Collection
import java.util.HashSet
import java.util.List
import java.util.stream.Collectors
import org.eclipse.core.resources.IContainer
import org.eclipse.core.resources.IFile
import org.eclipse.core.resources.IProject
import org.eclipse.core.resources.IResource
import org.eclipse.core.resources.ResourcesPlugin
import org.eclipse.core.runtime.CoreException
import org.eclipse.core.runtime.Path
import org.eclipse.emf.common.util.URI
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference
import org.eclipse.jface.text.contentassist.ICompletionProposal
import org.eclipse.jface.viewers.StyledString
import org.eclipse.osgi.util.NLS
import org.eclipse.xtext.Assignment
import org.eclipse.xtext.CrossReference
import org.eclipse.xtext.GrammarUtil
import org.eclipse.xtext.Keyword
import org.eclipse.xtext.RuleCall
import org.eclipse.xtext.conversion.impl.QualifiedNameValueConverter
import org.eclipse.xtext.naming.IQualifiedNameConverter
import org.eclipse.xtext.nodemodel.ICompositeNode
import org.eclipse.xtext.resource.IEObjectDescription
import org.eclipse.xtext.scoping.IScopeProvider
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal
import org.eclipse.xtext.ui.editor.contentassist.ConfigurableCompletionProposal.IReplacementTextApplier
import org.eclipse.xtext.ui.editor.contentassist.ContentAssistContext
import org.eclipse.xtext.ui.editor.contentassist.ICompletionProposalAcceptor
import org.eclipse.xtext.ui.editor.hover.IEObjectHover

import static com.google.common.base.Predicates.and
import static com.google.common.base.Predicates.not
import static com.google.common.collect.Lists.transform
import static com.modelsolv.reprezen.restapi.util.OAuth2Parameters.ACCESS_TOKEN_URL
import static com.modelsolv.reprezen.restapi.util.OAuth2Parameters.AUTHORIZATION_URL
import static com.modelsolv.reprezen.restapi.util.OAuth2Parameters.REDIRECT_URL
import static com.modelsolv.reprezen.restapi.util.OAuth2Parameters.REQUEST_TOKEN_URL
import static com.modelsolv.reprezen.restapi.util.OAuth2Parameters.TOKEN_URL
import static com.modelsolv.reprezen.restapi.xtext.parser.RepreZenParserUtils.getNodeBySemanticClass
import static com.modelsolv.reprezen.restapi.xtext.parser.RepreZenParserUtils.matchKeyword
import org.eclipse.xtext.resource.impl.AliasedEObjectDescription

/**
 * See https://www.eclipse.org/Xtext/documentation/304_ide_concepts.html#content-assist
 * on how to customize the content assistant.
 */
class RapidMLProposalProvider extends AbstractRapidMLProposalProvider {
	static final String QUERY = "query"
	static final String DATA_EXAMPLE_START = "'''";
	static final String DATA_EXAMPLE_END = "'''";
	static final String MEDIA_TYPES = RestapiPackage.Literals.RESOURCE_DEFINITION__MEDIA_TYPES.getName()

	/** 
	 * defaultPriority for cross-references 
	 */
	static final int DEFAUL_CROSS_REF_PRIORITY = 500
	val allInclusivePropertyKeywords = new HashSet<String>()
	String propertiesKeyword
	val autoRealizationsKeywords = new HashSet()
	@Inject package IScopeProvider scopeProvider
	@Inject package RapidMLGrammarAccess grammarAccess
	@Inject IQualifiedNameConverter qualifiedNameConverter
	@Inject package QualifiedNameValueConverter qualifiedNameValueConverter
	@Inject IEObjectHover hover

	@Inject new(RapidMLGrammarAccess grammarAccess) {
		var grammar = grammarAccess.getIncludedPropertiesAccess()
		propertiesKeyword = grammar.getPropertiesKeyword_2_1_2().getValue()
		allInclusivePropertyKeywords.add(grammar.getPropertiesKeyword_2_1_2().getValue())
		allInclusivePropertyKeywords.add(grammar.getAllKeyword_2_1_1().getValue())
		allInclusivePropertyKeywords.add(grammar.getOnlyKeyword_2_0_1().getValue())
		allInclusivePropertyKeywords.add(grammar.getWithKeyword_2_1_0().getValue())
		autoRealizationsKeywords.add(grammarAccess.getResourceAPIAccess().getAutoRealizationsKeyword_6_3_2())
		autoRealizationsKeywords.add(grammarAccess.getResourceAPIAccess().getWithKeyword_6_3_1())
	}

	override void complete_PropertyRealization(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		var Optional<ObjectRealization> realization = getObjectRealization(model)
		if (realization.isPresent()) {
			var Structure type = realization.get().getDataType()
			var List<Feature> excluding = Lists.newArrayList(realization.get().getExcludedProperties())
			// disabled because it breaks existing tests
			// excluding.addAll(Lists.transform(realization.get().getExclusivePropertyList(), new
			// Function<PropertyRealization, Feature>() {
			//
			// @Override
			// public Feature apply(PropertyRealization input) {
			// return input.getBaseProperty();
			// }
			// }));
			if (type !== null) {
				var String includeAllPropertiesProposal = getProposedIncludedProperties(type, excluding). //
				stream(). //
				// We need to use a converter to make sure reserved keywords are escaped
				map([name|getValueConverter().toString(name, grammarAccess.getFeatureNameRule().getName())]). //
				collect(Collectors.joining(", "))
				// proposal to include all properties at once
				acceptor.accept(
					createCompletionProposal(includeAllPropertiesProposal, null, null, DEFAUL_CROSS_REF_PRIORITY + 1,
						context.getPrefix(), context))
				completeIncludedProperties(type, excluding, acceptor, context)
			}
		} else {
			super.complete_PropertyRealization(model, ruleCall, context, acceptor)
		}
	}

	override void completePropertyRealization_BaseProperty(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) { // ignore this rule
	}

	override void completeIncludedProperties_OverriddenPropertyList(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		if (model instanceof ObjectRealization) {
			completeIncludedProperties(((model as ObjectRealization)).getDataType(),
				((model as ObjectRealization)).getExcludedProperties(), acceptor, context)
		}
	}

	override void completeIncludedProperties_ExcludedProperties(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		var Optional<ObjectRealization> realization = getObjectRealization(model)
		if (realization.isPresent()) {
			var List<Feature> excluding = Lists.newArrayList(
				transform(realization.get().getOverriddenPropertyList(), [ PropertyRealization input |
					return input.getBaseProperty()
				]))
			completeIncludedProperties(realization.get().getDataType(), excluding, acceptor, context)
		}
	}

	def protected Optional<ObjectRealization> getObjectRealization(EObject model) {
		var Optional<ObjectRealization> realization = Optional.absent()
		if (model instanceof RealizationContainer) {
			realization = Optional.fromNullable(((model as RealizationContainer)).getInlineObjectRealization())
		} else if (model instanceof ObjectRealization) {
			realization = Optional.of((model as ObjectRealization))
		}
		return realization
	}

	def private void completeIncludedProperties(Structure type, List<Feature> excluding,
		ICompletionProposalAcceptor acceptor, ContentAssistContext context) {
		var Iterable<String> properties = getProposedIncludedProperties(type, excluding)
		for (String feature : properties) {
			// We need to use a converter to make sure reserved keywords are escaped
			var String proposalText = getValueConverter().toString(feature,
				grammarAccess.getFeatureNameRule().getName())
			acceptor.accept(
				createCompletionProposal(proposalText, new StyledString(feature), null, DEFAUL_CROSS_REF_PRIORITY,
					context.getPrefix(), context))
		}
	}

	def private Collection<String> getProposedIncludedProperties(Structure type, List<Feature> excluding) {
		var ArrayList<Feature> list = Lists.newArrayList(type.getOwnedFeatures())
		list.addAll(InheritanceUtils.getInheritedFeatures(type))
		list.removeAll(excluding)
		return list.stream(). //
		map([property|property.getName()]). //
		collect(Collectors.toList())
	}

	override void completeAnonimousLinkDescriptor_ExclusivePropertyList(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		var EReference ref = RestapiPackage.eINSTANCE.getObjectRealization_ExclusivePropertyList()
		var Iterable<IEObjectDescription> candidates = getCrossReferenceProposalCreator().getScopeProvider().
			getScope(model, ref).getAllElements()
		var String includeAllPropertiesProposal = Joiner.on(", ").join(candidates)
		// $NON-NLS-1$
		acceptor.accept(
			createCompletionProposal(includeAllPropertiesProposal, null, null, 400 + /* defaultPriority */ 1,
				context.getPrefix(), context))
		for (IEObjectDescription candidate : candidates) {
			if(!acceptor.canAcceptMoreProposals()) return;
			acceptor.accept(createCompletionProposal(candidate.toString(), context))
		}
	}

	override void complete_CardinalityOverride(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if (model instanceof PropertyRealization) {
			var PropertyRealization includedProperty = (model as PropertyRealization)
			var Collection<Cardinality> allowedOverride = OverrideCardinalities.getOverrideCardinalities().
				getAllowedOverride(includedProperty)
			for (Cardinality nextOverride : allowedOverride) {
				acceptor.accept(createCompletionProposal(nextOverride.getLabel(), context))
			}
			return;
		}
	}

	override void complete_Cardinality(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		for (Cardinality next : FeatureCardinalities.ALL_CARDINALITIES) {
			acceptor.accept(createCompletionProposal(next.getLabel(), context))
		}
	}

	override void completeReferenceProperty_Inverse(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		val IReplacementTextApplier textApplier = new InverseReplacementTextApplier((model as ReferenceProperty),
			scopeProvider.getScope(model, RestapiPackage.Literals.REFERENCE_PROPERTY__INVERSE), qualifiedNameConverter,
			qualifiedNameValueConverter)
		val ICompletionProposalAcceptor oppositeAware = new ICompletionProposalAcceptor.Delegate(acceptor) {
			override void accept(ICompletionProposal proposal) {
				if (proposal instanceof ConfigurableCompletionProposal && textApplier !== null) {
					((proposal as ConfigurableCompletionProposal)).setTextApplier(textApplier)
				}
				super.accept(proposal)
			}
		}
		super.completeReferenceProperty_Inverse(model, assignment, context, oppositeAware)
	}

	override void completeKeyword(Keyword keyword, ContentAssistContext contentAssistContext,
		ICompletionProposalAcceptor acceptor) {
		// ZEN-3884 - temporarily disable code-assist for autoRealizations so it's not accessible in GUI
		// We need it to merge the topic branch which is still in incomplete state to master
		if (ConfigVariable.REPREZEN_ENABLE_AUTO_REALIZATION.isUnset() && autoRealizationsKeywords.contains(keyword)) {
			return;
		}
		var Optional<ICompositeNode> node = getNodeBySemanticClass(contentAssistContext.getCurrentNode(),
			RestapiPackage.Literals.TYPED_MESSAGE, RestapiPackage.Literals.RESOURCE_DEFINITION)
		if (node.isPresent()) {
			if (MEDIA_TYPES.equals(keyword.getValue())) {
				if (Iterables.any(node.get().getChildren(), matchKeyword(MEDIA_TYPES))) {
					return;
				}
			}
			if (allInclusivePropertyKeywords.contains(keyword.getValue())) {
				if (Iterables.any(node.get().getAsTreeIterable(), matchKeyword(propertiesKeyword))) {
					return;
				}
			}
		}
		// avoid proposal "query" location for response parameters
		if (contentAssistContext.getCurrentModel() instanceof MessageParameter) {
			var MessageParameter param = (contentAssistContext.getCurrentModel() as MessageParameter)
			if (param.getContainingMessage() instanceof TypedResponse && QUERY.equals(keyword.getValue())) {
				return;
			}
		}
		if (contentAssistContext.getCurrentModel() instanceof TypedMessage) {
			var TypedMessage message = (contentAssistContext.getCurrentModel() as TypedMessage)
			if (message.getActualType() === null) {
				if (GrammarUtil.containedKeywords(grammarAccess.getIncludedPropertiesRule()).contains(keyword) ||
					GrammarUtil.containedKeywords(grammarAccess.getReferenceEmbedRule()).contains(keyword) ||
					GrammarUtil.containedKeywords(grammarAccess.getReferenceLinkRule()).contains(keyword)) {
					return;
				}
			}
		}
		super.completeKeyword(keyword, contentAssistContext, acceptor)
	}

	override void completeImport_ImportedNamespace(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		if (model instanceof ImportDeclaration) {
			for (String namespace : RestapiModelUtils.getImportedNamespaces((model as ImportDeclaration))) {
				acceptor.accept(
					createCompletionProposal(namespace, namespace,
						RepreZenUIImages.getImage(RepreZenUIImages.IMG_PACKAGE), context))
			}
		}
	}

	override void completeImport_ImportURI(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		var Function<String, Void> pathAcceptor = [ String path |
			acceptor.accept(createCompletionProposal(NLS.bind("\"{0}\"", path), path, // $NON-NLS-1$
			RepreZenUIImages.getImage(RepreZenUIImages.IMG_ZEN_FILE), context))
			return null
		]
		var Function<IProject, IContainer> getRoot = [IProject input|return input.getFolder("models")]
		// $NON-NLS-1$ ;
		completeFileReference(model, isZenFile(), pathAcceptor, getRoot)
	}

	override void completeExternalExample_Path(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		var Function<String, Void> pathAcceptor = [ String path |
			acceptor.accept(createCompletionProposal(NLS.bind("\"{0}\"", path), path, // $NON-NLS-1$
			null, context))
			return null
		]
		var Function<IProject, IContainer> getRoot = [IProject input|return input]
		completeFileReference(model, and(not(isZenFile()), not(isResource())), pathAcceptor, getRoot)
	}

	override void completeSecuritySchemeParameter_Name(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		acceptor.accept(createCompletionProposal(AUTHORIZATION_URL, context))
		acceptor.accept(createCompletionProposal(TOKEN_URL, context))
		acceptor.accept(createCompletionProposal(REQUEST_TOKEN_URL, context))
		acceptor.accept(createCompletionProposal(ACCESS_TOKEN_URL, context))
		acceptor.accept(createCompletionProposal(REDIRECT_URL, context))
		super.completeSecuritySchemeParameter_Name(model, assignment, context, acceptor)
	}

	def static Predicate<IResource> isZenFile() {
		return [IResource resource|return WorkspaceUtils.isZenFile(resource)]
	}

	def static Predicate<IResource> isResource() {
		return [IResource resource|return resource.getName().startsWith(".")] // $NON-NLS-1$
	}

	def void completeFileReference(EObject model, Predicate<IResource> selectResource, Function<String, Void> accept,
		Function<IProject, IContainer> getRoot) {
		var URI uri = model.eResource().getURI()
		if (uri.isPlatform()) {
			var String platformPath = uri.toPlatformString(true)
			val IFile modelFile = ResourcesPlugin.getWorkspace().getRoot().getFile(new Path(platformPath))
			var IContainer modelsFolder = getRoot.apply(modelFile.getProject())
			try {
				modelsFolder.accept([ IResource resource |
					if (resource.getType() === IResource.FILE && !resource.equals(modelFile) &&
						selectResource.apply(resource)) {
						var String path = resource.getFullPath().makeRelativeTo(modelFile.getParent().getFullPath()).
							toString()
						accept.apply(path)
					}
					return true
				], IResource.DEPTH_INFINITE, IResource.NONE)
			} catch (CoreException e) { // ignore exception
			}

		}
	}

	override void completePrimitiveProperty_Type(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		super.completePrimitiveProperty_Type(model, assignment, context, acceptor)
	}

	override void completeReferenceProperty_Type(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		super.completeReferenceProperty_Type(model, assignment, context, acceptor)
	}

	override void complete_Feature(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		super.complete_Feature(model, ruleCall, context, acceptor)
		completeFeature_Restriction(model, context, acceptor, PrimitiveProperty, true)
	}

	override void completePrimitiveProperty_Restriction(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.completePrimitiveProperty_Restriction(model, assignment, context, acceptor)
		completeFeature_Restriction(model, context, acceptor, PrimitiveProperty, true)
	}

	override void completePrimitiveProperty_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		super.completePrimitiveProperty_Name(model, assignment, context, acceptor)
		completeFeature_Restriction(model, context, acceptor, PrimitiveProperty, false)
	}

	override void completeReferenceProperty_Restriction(EObject model, Assignment assignment,
		ContentAssistContext context, ICompletionProposalAcceptor acceptor) {
		super.completeReferenceProperty_Restriction(model, assignment, context, acceptor)
		completeFeature_Restriction(model, context, acceptor, ReferenceProperty, true)
	}

	override void completeReferenceProperty_Name(EObject model, Assignment assignment, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		super.completeReferenceProperty_Name(model, assignment, context, acceptor)
		completeFeature_Restriction(model, context, acceptor, ReferenceProperty, false)
	}

	def protected <T extends Feature> void completeFeature_Restriction(EObject model, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor, Class<T> eclass, boolean includeRestrictKeyword) {
		if (model instanceof Structure) {
			// property is not available, so we cannot use #isRestriction()
			var Structure structure = (model as Structure)
			var Collection<Feature> inherited = InheritanceUtils.getInheritedFeatures(structure)
			for (Feature feature : Iterables.filter(inherited, eclass)) {
				acceptor.accept(createCompletionProposal_PropertyRestriction(feature, context, includeRestrictKeyword))
			}
		}
	}

	def private ICompletionProposal createCompletionProposal_PropertyRestriction(Feature feature,
		ContentAssistContext context, boolean includeRestrictKeyword) {
		var String proposal = ""
		if (includeRestrictKeyword) {
			proposal += "restrict "
		}
		proposal += '''«feature.getName()»: '''
		if (feature instanceof PrimitiveProperty) {
			proposal += ((feature as PrimitiveProperty)).getType().getName()
		} else if (feature instanceof ReferenceProperty) {
			proposal += '''reference to «((feature as ReferenceProperty)).getType().getName()»'''
		}
		proposal += FeatureCardinalities.getFeatureCardinalities().getCardinality(feature).getLabel()
		return createCompletionProposal(proposal, context)
	}

// TODO KOS: this is generic way to propose "Name" literal for any EString
// references. For better usability need
// handle each case separately.
	override void complete_EString(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		complete_ID(model, ruleCall, context, acceptor)
	}

	override void complete_FeatureName(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		complete_ID(model, ruleCall, context, acceptor)
	}

	override protected void lookupCrossReference(CrossReference crossReference, EReference reference,
		ContentAssistContext contentAssistContext, ICompletionProposalAcceptor acceptor,
		Predicate<IEObjectDescription> filter) {
		var String ruleName = null
		if (crossReference.getTerminal() instanceof RuleCall) {
			ruleName = ((crossReference.getTerminal() as RuleCall)).getRule().getName()
		}
		lookupCrossReference(contentAssistContext.getCurrentModel(), reference, acceptor, filter,
			getProposalFactory(ruleName, reference, contentAssistContext))
	}

	override protected boolean isValidProposal(String proposal, String prefix, ContentAssistContext context) {
		// proposal valid if prefix is NL with tabs
		if (prefix !== null && prefix.contains("\t")) {
			// $NON-NLS-1$
			return true
		}
		return super.isValidProposal(proposal, prefix, context)
	}

	def protected Function<IEObjectDescription, ICompletionProposal> getProposalFactory(String ruleName,
		EReference reference, ContentAssistContext contentAssistContext) {

		val scope = getScopeProvider().getScope(contentAssistContext.getCurrentModel(), reference)

		return new Function<IEObjectDescription, ICompletionProposal>() {
			override ICompletionProposal apply(IEObjectDescription candidate) {
				if (candidate === null) {
					return null
				}
				var String proposal
				if ((candidate instanceof AliasedEObjectDescription) && (candidate.getName().getSegmentCount() > 1)) {
					proposal = qualifiedNameConverter.toString(candidate.getName())
				} else {
					proposal = qualifiedNameConverter.toString(candidate.getQualifiedName())
				}
				var EObject objectOrProxy = candidate.getEObjectOrProxy()
				var StyledString displayString = getStyledDisplayString(candidate)
				var image = getImage(objectOrProxy)
				var ICompletionProposal result = createCompletionProposal(proposal, displayString, image,
					contentAssistContext)
				if (result instanceof ConfigurableCompletionProposal) {
					((result as ConfigurableCompletionProposal)).setProposalContextResource(
						contentAssistContext.getResource())
					((result as ConfigurableCompletionProposal)).setAdditionalProposalInfo(objectOrProxy)
					((result as ConfigurableCompletionProposal)).setHover(hover)
					((result as ConfigurableCompletionProposal)).setTextApplier(
						new RepreZenQNReplacementTextApplier(
							contentAssistContext.getResource(), 
							scope,
							qualifiedNameConverter, 
							ruleName,
							valueConverter))
				}
				getPriorityHelper().adjustCrossReferencePriority(result, contentAssistContext.getPrefix())
				return result
			}
		}
	}

	override complete_RICH_TEXT(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		acceptor.accept(
			new ConfigurableCompletionProposal(DATA_EXAMPLE_START + " " + DATA_EXAMPLE_END,
				context.getReplaceRegion().getOffset(), context.getReplaceRegion().getLength(),
				DATA_EXAMPLE_START.length(), null, null, null, null));
	}

	override complete_JAVADOC_COMMENT(EObject model, RuleCall ruleCall, ContentAssistContext context,
		ICompletionProposalAcceptor acceptor) {
		// ZEN-2196 Code-assist for multiline comment
		acceptor.accept(
			new ConfigurableCompletionProposal("/**" + "  " + "*/", context.getReplaceRegion().getOffset(),
				context.getReplaceRegion().getLength(), "/** ".length(), null, null, null, null));
	}

}
