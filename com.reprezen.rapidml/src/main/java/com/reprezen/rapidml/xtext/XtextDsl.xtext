// automatically generated by Xtext
grammar com.reprezen.rapidml.xtext.XtextDsl with com.reprezen.rapidml.xtext.RepreZenTerminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
import "http://www.modelsolv.com/reprezen/rapidml/1.0"

ZenModel returns ZenModel:
	{ZenModel}
	(NL* 'namespace ' namespace = QualifiedName NL)?
	(NL* imports += Import)*
	(NL* documentation=ModelDocumentation)?
	(NL? ('rapidModel'))
	name=ID	
	BEGIN
	(NL+ ('with')? 'title' title=STRING)?
	(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	(resourceAPIs+=ResourceAPI)*
	(dataModels+=DataModel)*
	(primitiveTypesLibrary=PrimitiveTypesLibrary)?
	(mediaTypesLibrary=MediaTypesLibrary)?
	(linkRelationsLibrary=LinkRelationsLibrary)?
	(securitySchemesLibrary=SecuritySchemeLibrary)?
	NL? END NL*
;

/* Grammar fragments are not supported by serialization which we use for RAPID-ML import
 * It fails with an exception like: "Feature Method.responses holds 1 non-transient value(s), but exactly 0 are required."
 * Which is caused by 0 returned by !child.getSemanticTypesToCheck().contains(ctx.getEObject().eClass()) 
 * in AssignmentQuantityIntervalProvider.getMaxByParent()
 * where child is "extensions*", its semanticTypesToCheck Extensible, and ctx.getEObject().eClass() is Method
 */
/* 
fragment Extensions *:
	NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	;
*/

Import returns ImportDeclaration:
    'import' importedNamespace = QualifiedName 'from' importURI = STRING ('as' alias = ID)? NL
;

ResourceAPI returns ResourceAPI:
	{ResourceAPI}
	(documentation=Documentation)?
	NL+ 'resourceAPI'
	name=ID	
	(('version' version=STRING)? &
	('baseURI' baseURI=STRING)?)
	(BEGIN
	(NL+ ('with')? 'title' title=STRING)?
	(NL 'secured' 'by'?
		BEGIN
		(securedBy += AuthenticationMethod)*
		NL? END
	)?
	(
		NL+ 'with' 'autoRealizations'
		BEGIN 
		(autoRealizations+=RealizationModelLocation)+
		NL? END
	)?
	(ownedResourceDefinitions+=ResourceDefinition)*
	(definedMediaTypes+=MediaType)*	
	(definedLinkRelations+=LinkRelation)*	
	(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?
;

ResourceDefinition returns ResourceDefinition:
	CollectionResource | ObjectResource;

CollectionResource returns CollectionResource:
	{CollectionResource}
	(documentation=Documentation)?
	NL+ (default?='default')?
	'collectionResource'
	name=EString
	(('bound' 'to'?)?'type' dataType=[Structure|QualifiedName])
	(BEGIN
	(NL 'URI' URI=URI)?
	(NL 'secured' 'by'?
		BEGIN
		(securedBy += AuthenticationMethod)*
		NL? END
	)?
	(
		collectionParameters+=CollectionParameter |
		inlineObjectRealization=IncludedProperties |
		referenceTreatments+=ReferenceTreatment |
		definedLinkDescriptors+=NamedLinkDescriptor |
		(NL 'mediaTypes' BEGIN NL  mediaTypes+=[MediaType|MediaTypeQualifier] ((',' | NL) mediaTypes+=[MediaType|MediaTypeQualifier])* END) |
		methods+=Method |
		examples+=Example
	)*
	(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL?  END)?;
	
ObjectResource returns ObjectResource:
	{ObjectResource}
	(documentation=Documentation)?
	NL+ (default?='default')?
	'objectResource'
	name=EString
	(('bound' 'to'?)?'type' dataType=[Structure|QualifiedName])
	(BEGIN
	(NL 'URI' URI=URI)? 
	(NL 'secured' 'by'?
		BEGIN
		(securedBy += AuthenticationMethod)*
		NL? END
	)?
	(
		inlineObjectRealization=IncludedProperties |
		referenceTreatments+=ReferenceTreatment |
		definedLinkDescriptors+=NamedLinkDescriptor |
		(NL 'mediaTypes' BEGIN NL  mediaTypes+=[MediaType|MediaTypeQualifier] ((',' | NL) mediaTypes+=[MediaType|MediaTypeQualifier])* END) |
		methods+=Method |
		examples+=Example
	)*
		(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?
;

IncludedProperties returns ObjectRealization:
	{ObjectRealization}
	NL
	(
	('with'? 'only'? 'properties'
		BEGIN NL exclusivePropertyList+=PropertyRealization ((',' | NL) exclusivePropertyList+=PropertyRealization)* NL? END
	) |
	// new rule - inclusivePropertyList: ['with'] 'all' 'properties' [['including'] includedProperties] [['excluding'] excludedProperties]
	('with'? 'all' 'properties'
		(NL? 'including'? 
			BEGIN NL overriddenPropertyList+=PropertyRealization ((',' | NL) overriddenPropertyList+=PropertyRealization)* NL? END
		)?
		
		(NL? 'excluding' 
			BEGIN NL excludedProperties+=[Feature|FeatureName] ((',' | NL) excludedProperties+=[Feature|FeatureName])* NL? END
		)?
		
	)) 
;


PropertyRealization returns PropertyRealization:
	{PropertyRealization}
	baseProperty=[Feature|FeatureName]
	cardinality=CardinalityOverride?
	(BEGIN
		(constraints+=Constraint)*
	NL? END)?
;

URI returns URI:
	{URI}
	("/")? segments+=(URISegment | URISegmentWithParameter) ("/" segments+=(URISegment | URISegmentWithParameter))*
	(BEGIN (uriParameters+=URIParameter)* NL? END)?;

URISegment returns URISegment: 
	{URISegment}
	name = URISegmentRule
;

URISegmentWithParameter returns URISegmentWithParameter: 
	{URISegmentWithParameter}
	'{' name = URISegmentRule '}'
;

/** From https://tools.ietf.org/html/rfc3986#page-50
 *    segment       = *pchar
   segment-nz    = 1*pchar
   segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / "@" )
                 ; non-zero-length segment without any colon ":"
   pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"
   fragment      = *( pchar / "/" / "?" )
   pct-encoded   = "%" HEXDIG HEXDIG
   unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
   sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
                 / "*" / "+" / "," / ";" / "="
 */
URISegmentRule:
	STRING | (SegmentSymbol | INT| ID)+
;
SegmentSymbol:
	(Unreserved | PctEncoded | SubDelims | "@");
Unreserved:
	"-" | "." | "_" | "~";
PctEncoded:
	"%" INT (INT|ID) 
	// Xtext processes terminals first:
	// -  if we define our own DIGIT rule then it will never be achieved as the INT terminal will be recognized instead
	// - defining a new terminal is tricky and can easily break existing functionality
	;

SubDelims:
	"!" | "$" | "&" | "'" | "(" | ")" | "*" | "+" | "," | ";" | "=";
                 
	
/* PARAMETERS */

MessageParameter returns MessageParameter:
	{MessageParameter}
	(documentation=Documentation)?
	NL+ (required?='required')?
	'param'
	name=EString
	sourceReference=SourceReference
	('located'? 'in' httpLocation=HttpMessageParameterLocation)?
	(BEGIN NL
	(('default' default=STRING)? &
	('fixed' fixed=STRING)?)
		(
		// ZEN-3667 - make sure to make NL optional, or extensions won't work 
		NL* 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?
	;

CollectionParameter returns CollectionParameter:
	{CollectionParameter}
	(documentation=Documentation)?
	NL+ (required?='required')?
	'collectionParam'	
	name=EString
	sourceReference=SourceReference
	(BEGIN NL
	(('default' default=STRING)? &
	('fixed' fixed=STRING)?)
		(
		NL* 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?
	;

URIParameter returns URIParameter:
	MatrixParameter | TemplateParameter
;

MatrixParameter returns MatrixParameter: 
	{MatrixParameter}
	(documentation=Documentation)?
	NL+ (required?='required')?
	'matrixParam'
	name=EString
	sourceReference=PropertyReference
	(BEGIN NL
	(('default' default=STRING)? &
	('fixed' fixed=STRING)?)
	(
		NL* 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?
	;
	
TemplateParameter returns TemplateParameter:
	{TemplateParameter}
	(documentation=Documentation)?
	NL+ (required?='required')?
	'templateParam'
	uriSegment=[URISegmentWithParameter|EString]
	sourceReference=SourceReference
	(BEGIN NL
	(('default' default=STRING)? &
	('fixed' fixed=STRING)?)
	(
		NL* 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?
	;

SourceReference returns SourceReference:
	PropertyReference|PrimitiveTypeSourceReference
;
	
PropertyReference returns PropertyReference: 
	{PropertyReference}
	('bound' 'to'?)?
	'property'
	conceptualFeature=[PrimitiveProperty|FeatureName]
;

PrimitiveTypeSourceReference returns PrimitiveTypeSourceReference: 
	{PrimitiveTypeSourceReference}
	'of'? 'type'
	simpleType=[PrimitiveType]
;

Method returns Method:
	{Method}
	(documentation=Documentation)?
	NL+ 'method' 
	httpMethod=HTTPMethods
	(id=ID)?
	(BEGIN
		(NL 'secured' 'by'?
			BEGIN
			(securedBy += AuthenticationMethod)*
			NL? END
		)?
		(request = TypedRequest)?
		(responses+=TypedResponse)*
			(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?;
	
enum HTTPMethods returns HTTPMethods:
	PUT="PUT" | POST="POST" | DELETE="DELETE" | HEAD="HEAD" | GET="GET" | PATCH="PATCH" | TRACE = "TRACE" | CONNECT = "CONNECT" | OPTIONS = "OPTIONS";

enum HttpMessageParameterLocation returns HttpMessageParameterLocation:
	HEADER="header" | QUERY="query";
	
TypedRequest returns TypedRequest:
	{TypedRequest}
	(documentation=Documentation)?
	NL+ 'request' 'with'? (useParentTypeReference?='this')?
	(
		(('resource'? resourceType=[ResourceDefinition|QualifiedName])
		| ('type' dataType=[Structure|QualifiedName]))?
	)?
	(BEGIN
		(
			inlineObjectRealization=IncludedProperties |
			referenceTreatments+=ReferenceTreatment |
			(NL 'mediaTypes' BEGIN NL  mediaTypes+=[MediaType|MediaTypeQualifier] ((',' | NL) mediaTypes+=[MediaType|MediaTypeQualifier])* END) |
			parameters+=MessageParameter |
			examples+=Example
		)*
			(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?	
;

TypedResponse returns TypedResponse:
	{TypedResponse}
	(documentation=Documentation)?
	NL+ 'response' 'with'? (useParentTypeReference?='this')?
	(
		(('resource'? resourceType=[ResourceDefinition|QualifiedName])
		| ('type' dataType=[Structure|QualifiedName]))?
	)?
	('statusCode'statusCode=EInt)?
	(BEGIN
		(
			inlineObjectRealization=IncludedProperties |
			referenceTreatments+=ReferenceTreatment |
			(NL 'mediaTypes' BEGIN NL  mediaTypes+=[MediaType|MediaTypeQualifier] ((',' | NL) mediaTypes+=[MediaType|MediaTypeQualifier])* END) |
			parameters+=MessageParameter |
			examples+=Example
		)*
			(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?	
;

Example returns Example: 
	InlineExample|ExternalExample
;

InlineExample returns InlineExample: 
	{InlineExample}
	NL+ 'example' body=RICH_TEXT
;

ExternalExample returns ExternalExample: 
	{ExternalExample}
	NL+ 'externalExample' path=EString
;
	
/* LINKED RESOURCES  */	

ReferenceTreatment returns ReferenceTreatment:
	ReferenceEmbed|ReferenceLink
;

ReferenceEmbed returns ReferenceEmbed:
	{ReferenceEmbed}
	NL+ 'referenceEmbed' 
	'>' + referenceElement = [ReferenceElement|FeatureName]
	(BEGIN
	ownedReferenceRealization = ReferenceEmbedRealization
	(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?
	;

ReferenceEmbedRealization returns ReferenceRealization:
	{ReferenceRealization}
	(inlineObjectRealization=AnonimousLinkDescriptor)?
	(referenceTreatments+=ReferenceTreatment)*
	;	
	
ReferenceLink returns ReferenceLink:
	{ReferenceLink}
	NL+ 'referenceLink' 
	'>' referenceElement = [ReferenceElement|FeatureName]
	(BEGIN
	ownedReferenceRealization = ReferenceLinkRealization
	(NL 'linkRelation' linkRelation=[LinkRelation|EString])?
		(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?;
	
ReferenceLinkRealization returns ReferenceRealization:
	{ReferenceRealization}
	(NL 'targetResource' targetResource=[ResourceDefinition|QualifiedName])
	(((inlineObjectRealization=AnonimousLinkDescriptor)|(NL 'linkDescriptor' properties=[NamedLinkDescriptor|QualifiedName])))?
	;	
	
AnonimousLinkDescriptor returns ObjectRealization:
	{ObjectRealization}
	NL+ 'targetProperties' 
	(BEGIN NL exclusivePropertyList+=PropertyRealization (=>(','|NL) exclusivePropertyList+=PropertyRealization)* NL? END)?
;

NamedLinkDescriptor returns NamedLinkDescriptor:
	{NamedLinkDescriptor}
	NL+ (default?='default')?
	'linkDescriptor'
	name = EString 
    (BEGIN NL exclusivePropertyList+=PropertyRealization (=>(','|NL) exclusivePropertyList+=PropertyRealization)* NL? END)?
;
		
/* SERVICE DATA MODEL PACKAGE*/
	
DataModel returns DataModel:
	{DataModel}
	(documentation=Documentation)?
	NL+ 'dataModel'
	name=ID	
	BEGIN
	(NL+ ('with')? 'title' title=STRING)?
	(ownedDataTypes+=DataType)*
	NL? END
	;
	
Structure returns Structure:
	{Structure}
	(documentation=Documentation)?
	NL+ 'structure'
	name=EString 
	('extends' supertypes+=[Inheritable|QualifiedName] (',' 'and'? supertypes+=[Inheritable|QualifiedName])* )?
	(BEGIN
	(ownedFeatures+=Feature)*
	(ownedOperations+=Operation)*
	(dataExamples+=DataExample)*
		(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?;

DataType:
	Structure | SingleValueType
;	   

Inheritable: 
	Structure
;	   

DataExample returns DataExample: 
	InlineDataExample
;

InlineDataExample returns InlineDataExample: 
	{InlineDataExample}
	NL+ 'dataExample' body=RICH_TEXT
;
	
Feature returns Feature:
	ReferenceProperty | PrimitiveProperty;
			
ReferenceProperty returns ReferenceProperty:
	(documentation=Documentation)?
	NL+ (restriction?='restrict')? name=FeatureName
	':' ('as')?
	((((containment?='containing')|(container?='container')) ('reference'('to')?)?) | ('reference'('to')?))
	type=[Structure|QualifiedName]
	cardinality=Cardinality?
	('inverse'inverse=[ReferenceProperty|FeatureName])?
	(BEGIN
			(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?
	;

PrimitiveProperty returns PrimitiveProperty:
	{PrimitiveProperty}
	(documentation=Documentation)?
	NL+ (restriction?='restrict')? name=FeatureName
	':' ('to'|'as')? (readOnly?='readOnly')? (key?='key')?
	type=[SingleValueType|QualifiedName]
	cardinality=Cardinality?
	(BEGIN
		(constraints+=Constraint)*
			(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?
	;
	
SingleValueType: 
	Enumeration | UserDefinedType 
	;
	
// enum string Suit {SUIT_CLUBS:"clubs", SUIT_SPADES:"spadesâ€}
// enum int Record{ ONE:1, TWO:2 } 
Enumeration returns Enumeration:
	{Enumeration}
	(documentation=Documentation)?
	NL+ 'enum'
	baseType=[PrimitiveType|EString]
	name=ID 
	BEGIN
		(enumConstants+=EnumConstant)*
			(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END;

EnumConstant returns EnumConstant:
	{EnumConstant}
	(documentation=Documentation)?
	NL+ name=EString
	(':'(integerValue=EInt|literalValue=STRING))?
	;
		
SimpleType: 
	 PrimitiveType // |UserDefinedType
	;

UserDefinedType returns UserDefinedType:
	{UserDefinedType}
	(documentation=Documentation)?
	NL+ 'simpleType' name=EString 'defined'? 'as' baseType=[SimpleType|QualifiedName]
	(BEGIN
		(constraints+=Constraint)*
			(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?;
	
Constraint: LengthConstraint | ValueRangeConstraint | RegExConstraint;

RegExConstraint returns RegExConstraint:
	{RegExConstraint}
	NL 'matching'? 'regex' pattern=StringLiteral;
	
LengthConstraint returns LengthConstraint:
	{LengthConstraint}
	NL 'of'? 'length' (('from' 'minimum'? minLength=EInt)? ('up'? 'to' 'maximum'? maxLength=EInt)? | length=EInt);

ValueRangeConstraint returns ValueRangeConstraint:
	{ValueRangeConstraint}
	NL 'with'? 'valueRange'
	('from' 'minimum'? minValue=NumericValue ('inclusive' | minValueExclusive?='exclusive')?)?
	('up'? 'to' 'maximum'? maxValue=NumericValue ('inclusive' | maxValueExclusive?='exclusive')?)?;

PrimitiveTypesLibrary returns PrimitiveTypesLibrary:
	{PrimitiveTypesLibrary}
	NL+ 'primitiveTypesLibrary'
	name=ID 
	BEGIN
	(primitiveTypes+=PrimitiveType)*
	NL? END;
		
PrimitiveType returns PrimitiveType:
	{PrimitiveType}
	NL 'primitiveType'
	name=ID;

	
Cardinality returns Cardinality:
	('!' | '?' | '*' | '+') |
	('[' INT '..' (INT | '*') ']');
	
CardinalityOverride returns CardinalityOverride:
	('!' | '?' | '*' | '+') |
	('[' INT '..' (INT | '*') ']');

Operation returns Operation:
	{Operation}
	(documentation=Documentation)?
	NL+ 'operation'
	name=EString;

/* MEDIA TYPES AND LINK RELATIONS*/	

MediaTypesLibrary returns MediaTypesLibrary:
	{MediaTypesLibrary}
	NL+ 'mediaTypesLibrary'
	BEGIN
	(mediaTypes+=MediaType)*
	NL? END
	;
	
MediaType returns MediaType:
	{MediaType}
	(documentation=Documentation)?
	NL+ 'mediaType'
	name=MediaTypeQualifier
	(BEGIN
	(NL 'specURL' specURL=STRING)?
	(NL 'derivedFrom' '(' (derivedFrom+=[MediaType|MediaTypeQualifier]) (',' derivedFrom+=[MediaType|MediaTypeQualifier])* ')' )?
		(
		NL+ 'extensions'
		BEGIN (extensions+=Extension)+
		NL? END
	)?
	NL? END)?
	;
	
	
LinkRelationsLibrary returns LinkRelationsLibrary:
	{LinkRelationsLibrary}
	NL+ 'linkRelationsLibrary'
	(name=ID)?
	(BEGIN
		(definedLinkRelations+=LinkRelation)*
	NL? END)?
	;
	
LinkRelation returns LinkRelation:
	{LinkRelation}
	(documentation=Documentation)?
	NL+ 'linkRelation'
	name=LinkRelationName
	('specURL' specURL=STRING)?
	;
	
LinkRelationName:
	(ID ( '-' ID )* )
;

/* AutoRealization */

RealizationModelLocation returns RealizationModelLocation:
	{RealizationModelLocation}
	NL+ uri=STRING
;

/* Authentication support */

SecuritySchemeLibrary returns SecuritySchemeLibrary: 
	{SecuritySchemeLibrary}
	(documentation=Documentation)?
	NL+ 'securitySchemesLibrary'
	name=ID
	BEGIN
	(securitySchemes+=SecurityScheme)*
	NL? END
;

AuthenticationMethod returns AuthenticationMethod:
	{AuthenticationMethod}
	NL+ scheme=[SecurityScheme|QualifiedName]
	(BEGIN
	NL+ ('authorized' 'for'?)? 'scopes'
		(BEGIN NL+ scopes+=[SecurityScope|QualifiedName] (=>(','|NL) scopes+=[SecurityScope|QualifiedName])* NL? END)?
	NL? END)?
;

enum AuthenticationFlows returns AuthenticationFlows:
	IMPLICIT="IMPLICIT" | PASSWORD="PASSWORD" | APPLICATION="APPLICATION" | ACCESS_CODE="ACCESS_CODE";


SecurityScheme returns SecurityScheme:
	{SecurityScheme}
	(documentation=Documentation)?
	NL+ 'securityScheme' name=ID
	BEGIN
		NL 'type' type=AuthenticationType
		NL 'methodInvocation'
		BEGIN
			NL 'requires'? 'authorization'
			BEGIN
				(parameters += AuthParameter)*
			NL? END
			(errorResponses += TypedErrorResponse)*
		NL? END
		(NL 'defines'? 'scopes'
			BEGIN
				(scopes+=SecurityScope)+
			NL? END
		)?
		(NL+ 'uses'? 'flow' flow=AuthenticationFlows)?
		(NL 'settings'
			BEGIN
				(settings+=SecuritySchemeParameter)+
			NL? END
		)?
		(
			NL+ 'extensions'
			BEGIN (extensions+=Extension)+
			NL? END
		)?		
		NL? END
;

SecurityScope returns SecurityScope:
	{SecurityScope}
	(documentation=Documentation)?
	NL+ name=QualifiedName
;

SecuritySchemeParameter returns SecuritySchemeParameter:
	{SecuritySchemeParameter}
	(documentation=Documentation)?
	NL+ name=ID ':' value= EString
;

AuthParameter returns MessageParameter:
	MessageParameter
;

TypedErrorResponse returns TypedResponse:
	{TypedResponse}
	(documentation=Documentation)?
	NL+ 'errorResponse' 'statusCode' statusCode=EInt
;

enum AuthenticationType returns AuthenticationTypes:
	BASIC="basic" | OAUTH2="oauth2" | CUSTOM="custom";
	
/* COMMON */

ModelDocumentation returns Documentation:
	{Documentation}
	text=JAVADOC_COMMENT;
	
Documentation returns Documentation:
	{Documentation}
	NL+ text=JAVADOC_COMMENT;
	
Extension returns Extension:
	{Extension}
	NL+ name = ExtensionName ':' value=(EString | RICH_TEXT)
	;		
	
ExtensionName returns ecore::EString:
	(ID (('-'|'+'|'.') ID)*)|EString;
	
EInt returns ecore::EInt:
	'-'? INT;

EString returns ecore::EString:
	STRING | ID;

StringLiteral returns ecore::EString:
	RAW_STRING | STRING;

NumericValue returns ecore::EString:
	STRING | Decimal;

Decimal returns ecore::EString:
	EInt('.'INT)?;
	
QualifiedName:
	ID ('.' ID)*;

PropertyPath:
	ID ('.' ID)*;
	
MediaTypeQualifier:
	MediaTypeQualifierWOAsterisk | STRING;
	
FeatureName:
	EString | Keyword;

/* Certain keywords, like 'title', are commonly used as property names in data models. 
 * Normally, such keywords would need to be prefixed with a ^caret to be declared or 
 * referenced as property names. We can allow selected keywords to be used as property
 * names without the caret prefix by making these changes:
 *   - add the keyword as an alternate to the Keyword rule in XtextDsl.xtext
 *   - add the keyword to RestTerminalConverters.keywordsAsIdentifiers */
Keyword:
	'title';

/* A rule to define or reference a media type without using quotes.
 * Doesn't support the "*" symbols as it conflicts with ML_COMMENT terminal*/
MediaTypeQualifierWOAsterisk:
	MediaTypeFragment ('/' (MediaTypeFragment))?(';' MediaTypeFragment'='MediaTypeFragment)*; 
	//should support "text/html; charset=UTF-8"

MediaTypeFragment:
	(ID ( ('-'|'+'|'.') ID )* )
;
	